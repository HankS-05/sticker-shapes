# sticker-shapes
Sticker shapes project, started November 2025

## How it works
The premise of this program is to create closed shapes out of N smoothly connected copies of a curve segment. To form this shape, the curve segments can be scaled, rotated, flipped, and shifted. Imagine starting with an initial curve, call it a curve template. Create a copy of this initial curve, apply some transformations to it, and shift it so the copy's start point meets the original's end point. Then another copy of the initial curve is made, and again it is transformed and shifted to the new end point. This process is repeated until we can close the loop. 

To be smoothly connected to the previous curve, a new curve must be rotated by a certain angle according to the tangent at the start of the curve template, the tangent at the end of the curve template (because they are all copies this is the end of the previous curve), and the orientation of the previous curve. This can be also be done to a flipped copy of the curve, AKA a different parity (call them 0 and 1), which requires an opposite angle of rotation. Thus to return back to the start with a smooth connection, there must be a certain relationship between the parities of the curve segments, the start tangent, and the final tangent. If ltang is the angle of the start tangent of the curve template, rtang is the angle of the right tangent of the curve template, n0 is the number of curves with parity 0 and n1 is the number of curves with parity 1, for the curves to form a smoothly closed loop:

(rtang - ltang)(n0-n1) = 2*pi*n 

where n is an integer. I just look for solutions with n = -1, 0, 1. This is because the curves have to rotate by (rtang-ltang) to smoothly connect, and parities 0 and 1 rotate opposite each other. So to form a smoothly closed loop, they rotate one way n0 times and the other way n1 times, which must sum to a multiple of 2*pi so there isn't some angle "residue" at the end. The program looks for solutions that satisfy this by fixing ltang and always using the same starting value for the curve. Then it solves for rtang, and looks for points in the region (start, stop) which have the correct tangent to become the new end point. The program then runs for each of these plausible stop values. 

Given a list of parities and a refined stop point, N curves should be able to smoothly connect in a closed shape. The parities describe how they are flipped, and their rotation is set by this parity list. Translation is a simple process of moving the copy's start point to the new end point. But to reach the beginning again, each curve must be scaled correctly. To do this, an analogy is made between these curve segments and a vector running from the start of the curve to the end. If we again define the rotation between consecutive vectors by the tangents of the curve template and the parity list, we can create a set of vectors which is much more easy to work with than curves. We don't even have to worry about translating them, because if the vectors some to zero then a "head to toe" geometric sum (which we are doing with the actual curves) would connect the end point of the final vector to the start point of the first vector. This is the "passing go" property that we are interested in. So we can start out by scaling every curve vector uniformly, and only rotating them. Finding a scale list which makes the vectors sum to zero is then just a problem in linear algebra, where we have to find the nullspace of a matrix composed of these curve vectors as columns. 

We are essentially done. These scaled vectors will some to zero, and so when we apply the scales to the curve segments they will also return to the start. Because we were particular about the end point tangent, the end smoothly connects to the start. However our null space calculation produces scale lists which usually contain negative values. This creates a new kind of rotation which I did not initially anticipate. Rather than smoothly connecting the previous curve to the next, there is an additional rotation of 180 degrees (a different kind of flip than changing parity) which creates a sharp kink in the shape. Although these do not meet my initial requirement of being smoothly connected, the vast majority of solution shapes include these kinks. However I do think some of the kinked shapes look cool, and I do not want to remove them. 

To get a completely smooth shape, the curve vector null space can be manipulated to produce strictly positive (elementwise) column vectors. A positive vector can be found via linear programming (Ax >= 0), which I implement through CVXPY. While some null spaces will have no such vectors, if there exists a single strictly positive vector then there is a linearly independent positive vector for every column in the null space matrix. Imagine taking the one positive vector and multiplying it by 1 million. To create each linearly independent positive vector, add a colummn of the null space matrix to this huge positive vector. However this perturbation method creates vectors which are still very similar to each other (so our graphs will look boring). To get around this, I found the null space of each row of the original null matrix, and then multiplied them (for each row). That way I get a matrix with a few columns that all have row j = 0 for each row j. Then I find a strictly positive vector in each of these smaller row j = 0 matrices. For some this fails, because generally the number of rows is greated than the number of columns for these solution null matrices, and we can only have as many row j = 0 strictly positive vectors as we have columns of the null matrix. However for as many row j = 0 matrices as there are columns of the null space, this will produce a positive vector with one zero component (I'm not sure about the "as many ... as there are ..."). So we get a new "basis" for the strictly positive part of the null space where one component is zero for every vector. This is possible because if a positive vector exists, the whole positive part of the null space can be filled out. The most natural choice for quasi-basis vectors would then be those that lie on edges of the positive section. 

One thing I'm not sure about is if you can decompose these nonnegative vectors further to find those that have more than one zero. Let me know if you know. 

## How to actually use it

There are comments in the code which should guide you through how to find solutions. The solution class does everything, so you need to create an instance of it with the start, stop, g, num_points, and N you want. g is a paramaterized function and start and stop are values of this parameter (t). N is the number of curves, and num_points is just the number of points in each curve. Once you initialize the class you have to run self.find_solutions() to actually get the solution shapes. This runs through every parity list and every possible stop value. Then self.transform_null_space(parity list, stop) can give you a strictly positive null space for a solution with index (parity list, stop, sign = "mixed") and adds one with index (parity list, stop, sign = "positive"). You can graph a shape with scales from each column in the null space of each (parity list, stop, sign) solution with self.graph_all_solutions(). Then if you want to animate one, use self.animate_solution(parity list, stop, sign, mode, file_name, num_nodes = 3, alpha = 1, frame_num = 200). This picks solution with index (parity list, stop, sign) and goes through columns in the null space either in order, interpolating between (1 -> 2, 2 -> 3, 3 -> 1) if mode = "linear" or by passing through various nodes which take a dirichlet sample of the coefficients of the null space columns if mode = "random".

